cmake_minimum_required( VERSION 3.0 FATAL_ERROR )
project( lava VERSION 2.1.0 )
set( lava_VERSION_ABI 3)

set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/CMake")

# Default build type is Debug
if( NOT CMAKE_BUILD_TYPE )
  set( CMAKE_BUILD_TYPE Debug )
endif( NOT CMAKE_BUILD_TYPE )

if ( CMAKE_BUILD_TYPE MATCHES "Debug" )
  add_definitions( -DDEBUG )
endif( )

#add_definitions(-std=c++11)
SET(CMAKE_CXX_STANDARD 11)

find_package( Vulkan )

include_directories($ENV{VULKAN_SDK}/include)

#find_package( GLFW3 system 3.2.1 )

message(STATUS "Using find_package to locate Vulkan")
find_package(Vulkan)
message(STATUS "Vulkan FOUND = ${VULKAN_FOUND}")
message(STATUS "Vulkan Include = ${VULKAN_INCLUDE_DIR}")
message(STATUS "Vulkan Lib = ${VULKAN_LIBRARY}")

set(STBI_INCLUDE_DIR ../stbi)
find_package(STBI)

message(${STBI_INCLUDE_DIR})

find_package(GLFW)
find_package(GLM)

find_package( Boost COMPONENTS unit_test_framework )


option( LAVA_WITH_DEVICE_BUILDERS "enabling/disabling custom device builder" ON )
option( LAVA_WITH_EXAMPLES "LAVA examples" ON)
option( LAVAENGINE_WITH_COMPONENTS "LAVA with components" ON )

if ( LAVAENGINE_WITH_COMPONENTS )
  list(APPEND COMMON_FIND_PACKAGE_DEFINES LAVAENGINE_HASCOMPONENTS)
endif( )

if ( LAVA_WITH_DEVICE_BUILDERS )
  list(APPEND COMMON_FIND_PACKAGE_DEFINES LAVA_DEVICE_BUILDERS )
endif( )

#add glslang
option(ENABLE_GLSLANG_BINARIES "Enable GLSLang Binaries" OFF)
option(BUILD_TESTING OFF)
option(ENABLE_HLSL OFF)
add_subdirectory( vendor/glslang )

set_property(GLOBAL PROPERTY USE_FOLDERS ON)





string(TOUPPER ${PROJECT_NAME} UPPER_PROJECT_NAME)
string(TOLOWER ${PROJECT_NAME} LOWER_PROJECT_NAME)

set(PROJECT_INCLUDE_NAME ${${UPPER_PROJECT_NAME}_INCLUDE_NAME})
if(NOT PROJECT_INCLUDE_NAME)
  set(PROJECT_INCLUDE_NAME ${LOWER_PROJECT_NAME})
endif()

set(PROJECT_namespace ${${UPPER_PROJECT_NAME}_namespace})
if(NOT PROJECT_namespace)
  set(PROJECT_namespace ${PROJECT_INCLUDE_NAME})
endif()

if(MSVC)
  set(CMAKE_MODULE_INSTALL_PATH ${PROJECT_NAME}/CMake)
else()
  set(CMAKE_MODULE_INSTALL_PATH share/${PROJECT_NAME}/CMake)
endif()

set(GIT_REVISION "0")

macro(common_find_package_post)
  if(WIN32)
    set(__system Win32)
  endif()
  if(APPLE)
    set(__system Darwin)
  endif()
  if(CMAKE_SYSTEM_NAME MATCHES "Linux")
    set(__system Linux)
  endif()

  list(APPEND COMMON_FIND_PACKAGE_DEFINES ${__system})
  list(APPEND COMMON_FIND_PACKAGE_DEFINES ${UPPER_PROJECT_NAME}_USE_CXX11)

  include(TestBigEndian)
  test_big_endian(BIGENDIAN)
  if(BIGENDIAN)
    list(APPEND COMMON_FIND_PACKAGE_DEFINES ${UPPER_PROJECT_NAME}_BIGENDIAN)
  else()
    list(APPEND COMMON_FIND_PACKAGE_DEFINES ${UPPER_PROJECT_NAME}_LITTLEENDIAN)
  endif()

  # Write defines.h and options.cmake
  if(NOT PROJECT_INCLUDE_NAME)
    message(FATAL_ERROR "PROJECT_INCLUDE_NAME not set, old or missing Common.cmake?")
  endif()
  if(NOT __options_cmake_file)
    set(__options_cmake_file ${CMAKE_CURRENT_BINARY_DIR}/options.cmake)
  endif()

  configure_file(${CMAKE_SOURCE_DIR}/CMake/cpp/defines.h
    ${PROJECT_BINARY_DIR}/include/${PROJECT_INCLUDE_NAME}/defines.h @ONLY)
  set(__defines_file
    "${CMAKE_CURRENT_BINARY_DIR}/include/${PROJECT_INCLUDE_NAME}/defines${__system}.h")

  set(__defines_file_in ${__defines_file}.in)
  set(__options_cmake_file_in ${__options_cmake_file}.in)
  file(WRITE ${__defines_file_in}
    "// generated by CommonFindPackage.cmake, do not edit.\n\n"
    "#ifndef ${PROJECT_NAME}_DEFINES_${__system}_H\n"
    "#define ${PROJECT_NAME}_DEFINES_${__system}_H\n\n")
  file(WRITE ${__options_cmake_file_in} "# Optional modules enabled during build\n")
  foreach(DEF ${COMMON_FIND_PACKAGE_DEFINES})
    add_definitions(-D${DEF}=1)
    file(APPEND ${__defines_file_in}
      "#ifndef ${DEF}\n"
      "#  define ${DEF} 1\n"
      "#endif\n")
    if(NOT DEF STREQUAL SYSTEM)
      file(APPEND ${__options_cmake_file_in} "set(${DEF} ON)\n")
    endif()
  endforeach()
  file(APPEND ${__defines_file_in} "\n#endif\n")

  # configure only touches file if changed, saves compilation after reconfigure
  configure_file(${__defines_file_in} ${__defines_file} COPYONLY)
  configure_file(${__options_cmake_file_in} ${__options_cmake_file} COPYONLY)

  if(CMAKE_MODULE_INSTALL_PATH)
    install(FILES ${__options_cmake_file}
            DESTINATION ${CMAKE_MODULE_INSTALL_PATH} COMPONENT dev)
    install_files(include/${PROJECT_INCLUDE_NAME}
      FILES ${PROJECT_BINARY_DIR}/include/${PROJECT_INCLUDE_NAME}/defines.h
            ${__defines_file} COMPONENT dev)
  else()
    message(FATAL_ERROR
      "CMAKE_MODULE_INSTALL_PATH not set, old or missing Common.cmake?")
  endif()

  include(${__options_cmake_file})

  if(Boost_FOUND) # another WAR for broken boost stuff...
    set(Boost_VERSION
      ${Boost_MAJOR_VERSION}.${Boost_MINOR_VERSION}.${Boost_SUBMINOR_VERSION})
  endif()
  if(OPENMP_FOUND)
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}")
    if(NOT MSVC)
      set(CMAKE_SHARED_LINKER_FLAGS
        "${CMAKE_SHARED_LINKER_FLAGS} ${OpenMP_CXX_FLAGS}")
    endif()
  endif()
  if(MPI_FOUND)
    include_directories(SYSTEM ${MPI_C_INCLUDE_PATH} ${MPI_CXX_INCLUDE_PATH})
  endif()

  if(CUDA_FOUND)
    find_cuda_compatible_host_compiler()
  endif()

  set(__configure_msg "${PROJECT_NAME} [${GIT_STATE}]")
  if(${PROJECT_NAME}_FIND_PACKAGES_FOUND AND NOT COMMON_FIND_PACKAGE_QUIET)
    set(__configure_msg
      "${__configure_msg} with${${PROJECT_NAME}_FIND_PACKAGES_FOUND}")
  endif()
  if(${PROJECT_NAME}_FIND_PACKAGES_NOTFOUND)
    set(__configure_msg
      "${__configure_msg} without${${PROJECT_NAME}_FIND_PACKAGES_NOTFOUND}")
  endif()
  #common_graph(${PROJECT_NAME})
  message(STATUS ${__configure_msg})
endmacro()


common_find_package_post( )

add_subdirectory( lava )
if( GLFW3_FOUND )
  add_subdirectory( glfwLava )
endif( )

if( QT5CORE_FOUND )
  add_subdirectory( qtLava )
endif( )

#add_subdirectory( lavaUtils )
#add_subdirectory( lavaEngine )

add_subdirectory( demos )

if(${Boost_FOUND})
#  add_subdirectory(tests)
endif()


include( glsl2spv )

# add a target to generate API documentation with Doxygen
find_package(Doxygen)
if(DOXYGEN_FOUND)
  configure_file(Doxyfile.in ${PROJECT_BINARY_DIR}/Doxyfile @ONLY IMMEDIATE)
  if(NOT MSVC)
    add_custom_target(doc 
      COMMAND ${DOXYGEN_EXECUTABLE} ${PROJECT_BINARY_DIR}/Doxyfile
      WORKING_DIRECTORY "${PROJECT_BINARY_DIR}"
      COMMENT "Generating API documentation with Doxygen" VERBATIM
    )
  endif( )
endif(DOXYGEN_FOUND)